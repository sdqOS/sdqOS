<!DOCTYPE html>
<html lang="cn">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Text</title>
    <!-- 导入css -->
    <link rel="icon" href="/text.png">
    <link rel="stylesheet" href="/style.css"/>
  <meta name="generator" content="Hexo 5.4.2"></head>
  <body>

  <div id="page-container">
    <span class="pai">
    <a class="kong" href="/"> 主页 </a>
    <a class="kong" href="/archives"> 分类 </a>
    <a class="kong" href="/about"> 关于 </a>
</span>

    <div id="content-wrap">
        <div class="container">
          <!-- 点击文章 -->
<div>
  <h1>数据结构 必背内容</h1>
  <wenzhang>
      <div class="contents">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-text">数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="toc-text">数据项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"><span class="toc-text">数据元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-text">数据对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-text">数据处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">抽象数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9C%B0%E5%B7%A5%E4%BD%9C"><span class="toc-text">原地工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="toc-text">完全图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%AE%8C%E5%85%A8%E5%9B%BE"><span class="toc-text">有向完全图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86"><span class="toc-text">广度遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-text">串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2"><span class="toc-text">子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-text">树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E5%AD%99"><span class="toc-text">子孙</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E7%BB%93%E7%82%B9%E4%B8%8E%E5%8F%8C%E4%BA%B2%E7%BB%93%E7%82%B9"><span class="toc-text">孩子结点与双亲结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6"><span class="toc-text">结点的度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%BA%A6"><span class="toc-text">树的度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90"><span class="toc-text">平衡因子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">生成树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">物理结构(存储结构)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2"><span class="toc-text">线索</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-text">广义表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-text">强连通分量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-text">结点的带权路径长度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A5%96%E5%85%88"><span class="toc-text">祖先</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">模式匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">单循环链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2-1"><span class="toc-text">线索</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-text">图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-text">折半查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS"><span class="toc-text">广度优先搜索(BFS)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%BC%96%E7%A0%81"><span class="toc-text">前缀编码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8-1"><span class="toc-text">广义表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="toc-text">树的高度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%82%E5%85%84%E5%BC%9F"><span class="toc-text">堂兄弟</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9"><span class="toc-text">叶子结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97"><span class="toc-text">森林</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-text">树的路径长度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6-WPL"><span class="toc-text">树的带权路径长度(WPL)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-text">哈夫曼树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-text">哈夫曼编码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E4%B8%AD%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6"><span class="toc-text">图中顶点的度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E5%9B%BE"><span class="toc-text">子图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="toc-text">连通图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91"><span class="toc-text">网</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS"><span class="toc-text">深度优先搜索(DFS)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%9E%E8%B7%AF"><span class="toc-text">简单回路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%B7%AF%E5%BE%84"><span class="toc-text">简单路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6-ASL"><span class="toc-text">平均查找长度(ASL)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-1"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE-%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE"><span class="toc-text">分块查找(索引查找)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shell%E6%8E%92%E5%BA%8F"><span class="toc-text">shell排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">内部排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">外部排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-text">不稳定排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F"><span class="toc-text">稳定排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95"><span class="toc-text">气泡排序法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-1"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="toc-text">强连通图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-text">连通分量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">基数排序</span></a></li></ol>
      </div>
      <p><strong>数据结构学习笔记</strong></p>
<span id="more"></span>

<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>数据是描述客观事物的符号, 是能够被计算机输入, 识别, 处理的各种符号, 是计算机化的信息</p>
<h1 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h1><p>数据不可分割的最小单位, 一个元素由若干个数据项构成</p>
<h1 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h1><p>它是组成数据的基本单位, 是数据集合中的个体, 在计算机程序中, 通常作为一个整体进行考虑和处理</p>
<h1 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h1><p>是性质相同的数据元素的集合, 是数据的一个子集</p>
<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><p>是指对数据进行查找, 插入, 删除, 合并, 排序, 统计以及简单计算等的操作过程</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>是研究数据元素之间抽象化的相互关系和这种关系在计算机中的存储表示(即数据的逻辑结构和物理结构), 并对这种结构定义相适应的运算, 设计出相应的算法, 且确保经过这些运算后所得到的新结构仍然是原来的结构类型</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据类型是一个值的集合和定义在这个值集上的一组操作的总称</p>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><p>是指一个数学模型以及定义在该模型上的一组操作抽象数据类型的定义取决于它的一组逻辑特性, 而与其在计算机内部如何表示和实现无关</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>解决一个问题的方法和步骤</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>T(N)＝O(F(N)), 它表示随问题规模Ｎ增大, 算法执行时间增长率与F(N)的增长率相同, F(N)算法的时间复杂性</p>
<h1 id="原地工作"><a href="#原地工作" class="headerlink" title="原地工作"></a>原地工作</h1><p>算法执行时, 若额外空间相对于输入数据量来说是常数, 则称此算法为原地工作</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>一种数据结构, 是N(N&gt;=# )个同质元素的有限序列, 除首尾元素外, 每个元素有唯一的前驱和唯一的后继</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>是一种受限线性表, 是先进先出的线性表</p>
<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p>在队列的顺序存储结构中, 把存储空间的首尾逻辑上相连, 构成一个环, 使得存储空间上只要有空余的地址, 就可以继续进行入队列操作, 极大利用了物理空间用头部和尾部两个指示器表示队列头和队列尾, 插入在尾部进行, 删除在头部进行</p>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>每一个数据元素, 都需用两部分来存储：一部分用于存放数据元素值, 称为数据域；另一部分用于存放直接后继结点的地址(指针), 称为指针域, 元素的存储空间可以连续, 也可以是不连续的而数据元素之间的逻辑关系由指针域来确定</p>
<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>线性表采用链式存储时, 每个结点除一个数据域外, 包含两个指针域, 一个指向该结点的直接后继, 一个指向该结点的直接前驱, 这种方式构成的链表, 即为双向链表</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>是插入排序的一种, 又叫缩小增量排序, 先按增量进行分组, 组内插入排序, 然后每次缩短增量, 再进行分组和组内插入排序,  直到增量为1时, 进行最后一次排序止</p>
<h1 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h1><p>任何一个有N个结点的无向图, 若其边数为N(N-# )/# , 则这个无向图就是完全图</p>
<h1 id="有向完全图"><a href="#有向完全图" class="headerlink" title="有向完全图"></a>有向完全图</h1><p>任何一个有N个结点的有向图, 若其弧个数为N(N-# )个, 则这个有向图就是有向完全图</p>
<h1 id="广度遍历"><a href="#广度遍历" class="headerlink" title="广度遍历"></a>广度遍历</h1><p>按层次编历方式, 从某一点V0开始遍历它的所有邻接点V1, V2……, 再依次访问V1, V2的所有未被访问过的邻接点, 直到所有的点均遍历完成</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>数据元素的某个数据项的值, 用它可以标识列表的一个或一组元素</p>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p>串是字符线性的有限集合</p>
<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><p>串中任意个连续的字符组成的子序列称作该串的子串</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>是一种受限线性表, 是插入和删除操作在同一端进行的, 是后进先出的线性表</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是n(n&gt;=# )个结点的有限集在任意一棵非空树中：</p>
<p>(# )有且仅有一个特殊的称为根的结点;              </p>
<p>(# )当n&gt;1时, 其余结点可分成m(m&gt;# )个互不相交的有限集T1, T2, , Tm, 其中每一个集合本身又是一棵树, 并且称为根的子树</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树是每个结点至多有两个孩子结点的一种树其中两个孩子结点分别被称为左孩子结点和右孩子结点</p>
<h1 id="子孙"><a href="#子孙" class="headerlink" title="子孙"></a>子孙</h1><p>子孙结点以某结点为根的子树中的任一结点都称为该结点的子孙</p>
<h1 id="孩子结点与双亲结点"><a href="#孩子结点与双亲结点" class="headerlink" title="孩子结点与双亲结点"></a>孩子结点与双亲结点</h1><p>树中某个结点的子树的根结点称为该结点的孩子结点相反, 称该结点为孩子结点的双亲结点</p>
<h1 id="结点的度"><a href="#结点的度" class="headerlink" title="结点的度"></a>结点的度</h1><p>树的某个结点的分支(子树)个数叫做该结点的度</p>
<h1 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h1><p>树的度是树中所有结点的最大度数</p>
<h1 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h1><p>结点的左子树深度与右子树深度之差</p>
<h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p>一个连通图的生成树是指一个极小连通子图, 它含有图中的全部顶点, N-1条边</p>
<h1 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h1><p>深度为K, 且有2K -1个结点的二叉树</p>
<h1 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构(存储结构)"></a>物理结构(存储结构)</h1><p>物理结构又称为数据的存储结构, 是指数据的逻辑结构在计算机中的映像(表示), 即数据结构在计算机中的存储方法</p>
<h1 id="线索"><a href="#线索" class="headerlink" title="线索"></a>线索</h1><p>在二叉树中, 利用空余的指针指向二叉树某种遍历方式的结点的前驱和后继, 这种指向前驱和后继的指针, 叫线索</p>
<h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>对二叉树以某种次序进行遍历并加上线索的过程叫做线索化线索化了的二叉树称为线索二叉树</p>
<h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p>广义表简称表, 是零个或多个原子表所组成的有限序列</p>
<h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><p>有向图的极大强连通子图, 称为有向图的强连通分量</p>
<h1 id="结点的带权路径长度"><a href="#结点的带权路径长度" class="headerlink" title="结点的带权路径长度"></a>结点的带权路径长度</h1><p>该结点到树根之间的路径长度与结点上权的乘积</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>在一个已排好序的记录子集的基础上, 每一步将下一个待排序的记录有序地插入到已排好序记录的子集上, 直到将所有待排记录全部插入为止</p>
<h1 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a>祖先</h1><p>一个结点的祖先是指从根结点到该结点的路径上的所有结点</p>
<h1 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构是数据元素的集合以及定义在该集合上的关系</p>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>子串的定位操作称作串的模式匹配</p>
<h1 id="单循环链表"><a href="#单循环链表" class="headerlink" title="单循环链表"></a>单循环链表</h1><p>是单链表的另一种形式, 它是一个首尾相接的链表, 表中最后一个结点的指针域由null改为指向头结点或线性表的第一个结点, 整个链表形成了一个环．</p>
<h1 id="线索-1"><a href="#线索-1" class="headerlink" title="线索"></a>线索</h1><p>在二叉树的存储结构中, 必有Ｎ＋１个空域, 利用这些空域存放某种遍历的前驱和后继, 其中指向前驱和后继的指针叫线索．</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是顶点与边的集合一般表示为一个二元组, 即, 图G=(V, E), 各个顶点之间是多对多的关系</p>
<h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h1><p>对于顺序存储的有序表, 先取中间位置的记录关键字与所给的关键字进行比较, 若相等, 则查找成功, 否则, 若给定的关键字比中间的关键字大, 在原表的后半部分比较, 反之, 在原表的前半部分比较, 如此反复, 逐步缩小范围, 直到找到为止, 或找不到, 最后查找范围为空．</p>
<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>在图G的所有生成树中, 树权值最小的那棵生成树, 称作最小生成树．</p>
<h1 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h1><p>首先访问出发点v, 接着依次访问v的所有邻接点w1, w2, …, wt, 然后再依次访问与wl, w2, …, wt邻接的所有未曾访问过的顶点依此类推, 直至图中所有和源点v有路径相通的顶点都已访问到为止此时从v开始的搜索过程结束</p>
<p>(若G是连通图, 则遍历完成;否则, 在图C中另选一个尚未访问的顶点作为新源点继续上述的搜索过程, 直至G中所有顶点均已被访问为止)</p>
<h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><p>对满二叉树的结点从上到下, 从左到右进行依次进行编号, 若有一棵二叉树的每一个结点都与深度为K的满二叉树中编号都一一对应时, 只是最后一层不满, 称做完全二叉树</p>
<h1 id="前缀编码"><a href="#前缀编码" class="headerlink" title="前缀编码"></a>前缀编码</h1><p>任何一个字符的编码都不是另一个字符编码的前缀, 这种编码叫做前缀编码</p>
<h1 id="广义表-1"><a href="#广义表-1" class="headerlink" title="广义表"></a>广义表</h1><p>是零个或多个原子表所构成的有序序列</p>
<h1 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>利用二叉树的一些空闲指针指向该结点的前驱或后继, 这种指针叫线索, 线索后了的二叉树, 称为线索二叉树</p>
<h1 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h1><p>树中所有结点的层次的最大值</p>
<h1 id="堂兄弟"><a href="#堂兄弟" class="headerlink" title="堂兄弟"></a>堂兄弟</h1><p>同一层上不同双亲的结点, 互称堂兄弟</p>
<h1 id="叶子结点"><a href="#叶子结点" class="headerlink" title="叶子结点"></a>叶子结点</h1><p>度为 #  的结点, 即没有后继的结点</p>
<h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><p>M棵互相不相交的树构成的集合, 将一棵非空树的根结点删除, 树就变成了森林</p>
<h1 id="树的路径长度"><a href="#树的路径长度" class="headerlink" title="树的路径长度"></a>树的路径长度</h1><p>树中每个结点到根结点的路径长度之和</p>
<h1 id="树的带权路径长度-WPL"><a href="#树的带权路径长度-WPL" class="headerlink" title="树的带权路径长度(WPL)"></a>树的带权路径长度(WPL)</h1><p>树中所有叶子结点的带权路径长度之和</p>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>设有N个权值的结点构造一棵有N个叶子结点的二叉树, 其中WPL最小的那棵树, 为哈夫曼树</p>
<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>一般以N种字符出现的频率做权值, 构造哈付曼树, 左孩子边做0, 右孩子边做1, 那么从根到叶子结点经过的0和1序列, 构成了哈夫曼编码</p>
<h1 id="图中顶点的度"><a href="#图中顶点的度" class="headerlink" title="图中顶点的度"></a>图中顶点的度</h1><p>顶点V的度是图中和顶点V相关联的边的数目包括入度和出度两种</p>
<h1 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h1><p>图G=(V, E)与图G1=(V1, E1), 若V1包含于V, 且E1包含于E, 则G1是G的子图</p>
<h1 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h1><p>对于无向图, 若V1到V2有路径, 称V1V2是连通的, 若图中任意两点都是连通的, 则称该无向图是连通图</p>
<h1 id="网"><a href="#网" class="headerlink" title="网"></a>网</h1><p>图的弧或边有与它相关的有意义的数, 称作权, 带有权值的图称作网</p>
<h1 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h1><p>类似树的先序遍历, 在图中任选一个顶点作为出发顶点V0, 访问V0后, 依次从V0的没被访问过的邻接点出发进行深度优先搜索直到与V0所连通的所有顶点均被访问如果, 此时图中还有顶点尚未访问, 则从剩余的顶点中再任选一个顶点作为出发顶点V0, 重复上述过程, 直到图中全部顶点均被访问为止</p>
<h1 id="简单回路"><a href="#简单回路" class="headerlink" title="简单回路"></a>简单回路</h1><p>除了第一个顶点和最后一个顶点之外, 其余顶点均不相同的回路称为简单回路</p>
<h1 id="简单路径"><a href="#简单路径" class="headerlink" title="简单路径"></a>简单路径</h1><p>在用一个顶点序列表示一条路径时, 若序列中没有相同的顶点重复出现, 则称其为简单路径</p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>根据给定的关键字值, 在特定的表中, 确定一个其关键字与给定值相同的数据元素, 并返回该数据元素在列表中的位置这个过程叫查找</p>
<h1 id="平均查找长度-ASL"><a href="#平均查找长度-ASL" class="headerlink" title="平均查找长度(ASL)"></a>平均查找长度(ASL)</h1><p>为确定数据元素在表中的位置, 需和给定值进行比较的关键字个数的数学期望值, 成为查找算法在查找成功的平均查找长度</p>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p>它或是一棵空树, 或是有下面性质的树：若左或右子树不空, 左子树所有结点值小于根结点, 而右子树所有结点值大于根结点的值, 其左右子树也是二叉排序树</p>
<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>对于给定的关键字K, 从线性表的第一个(或最后一个)元素开始, 依次向后(或前)与元素的关键字比较, 若某个记录的关键字与K 相等, 查找成功, 否则失败</p>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>或是一棵空树, 或左右子树高度差的绝对值小于等于1而且, 左右子树也是平衡二叉树</p>
<h1 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h1><p>在一个已排好序的基础上, 每一步将下一个待排序记录插到已排好记录的子集上, 使之重新有序, 直到所有待排记录插完为止</p>
<h1 id="分块查找-索引查找"><a href="#分块查找-索引查找" class="headerlink" title="分块查找(索引查找)"></a>分块查找(索引查找)</h1><p>分块查找以前两个为基础, 将待查记录分成若干块, 每块的关键字无序, 但每块的关键字的最大值有序, 查找时, 先查找到待查记录所在的块, 再在块内进行顺序查找找块时, 即可以用折半查找, 也可用顺序查找</p>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>由某个集合上的偏序集得到该集合上的一个全序, 这个操作叫做拓扑排序</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>将两个或两个以上的有序表合并成一个新的有序表, 开始将每个元素当成是一个个单独的有序表, 逐渐表个数以原来一半的速度递减, 每个表的长度却是原来长度的2倍增加, 不断重复, 直到最后是一个表, 而表的长度是元素个数为止</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>根据关键字的递减或递增的次序, 把文件中的各个记录依次排列起来, 可使一个无序的数据元素序列变成一个有序的序列的操作</p>
<h1 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h1><p>它是插入排序的一种, 又叫缩小增量排序, 先按增量进行分组, 组内插入排序, 然后每次缩短增量, 再进行分组和组内插入排序,  直到增量为1时, 进行最后一次排序止</p>
<h1 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h1><p>指的是待排序记录存放在计算机存储器中进行的排序过程；</p>
<h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><p>指的是待排序记录的数量很大, 以致内存一次不能容纳全部记录, 在排序过程中对外存进行访问的排序过程</p>
<h1 id="不稳定排序"><a href="#不稳定排序" class="headerlink" title="不稳定排序"></a>不稳定排序</h1><p>假设Ki=Kj(1≤i≤n, 1≤j≤n, i≠j), 且在排序前的序列中Ri领先于Rj(即i＜j)若在排序后的序列中Rj 领先于Ri , 则称所用的排序方法是不稳定的</p>
<h1 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h1><p>假设Ki=Kj(1≤i≤n, 1≤j≤n, i≠j), 且在排序前的序列中Ri领先于Rj(即i＜j)若在排序后的序列中Ri仍领先于Rj, 则称所用的排序方法是稳定的</p>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>第1遍, 将初始文件中的记录R1看作有序子文件, 将R2插入这个子文件中若R2的关键字小于R1的关键字, 则R2插在R1的前面, 否则R2插在R1的后面第2遍, 将R3插入前面的两个记录的有序子文件中, 得到3个记录的有序子文件依此类推, 继续进行下去, 直到将Rn插入到前面的n-1个记录的有序子文件中, 最后得到n个记录的有序文件 </p>
<h1 id="气泡排序法"><a href="#气泡排序法" class="headerlink" title="气泡排序法"></a>气泡排序法</h1><p>气泡排序的过程很简单从第一记录开始, 相邻的两个记录关键字进行比较, 若顺序不对, 立即交换, 直至N-1个与第N个比较为止得到一个最大(或最小)的关键字记录的结果位置</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序是每一趟在n-i+# (i= # , # , 3…n-# )个记录中选择关键字最小的记录作为有序序列中第i个记录其中最简单的是简单选择排序</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序的基本思想是把当前待排序的记录, 存放到整个表排好序后, 它应当在的最终位置上将原来的待排序表分割成两部分, 其中一部分表中的关键字均比另一部分表中的关键字小然后, 分别对两部分表用同样的方式进行排序, 直到整个表排好序</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>首先将根结点的记录与当前树中具有最大序号的记录交换, 把交换后具有最大序号的记录输出, 得到一个排序的结果这时的树不再是堆树, 排序暂时停止然后, 必须把树重新调整成堆树, 再重复上述过程, 直到所有记录都排好序</p>
<h1 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是把两个或两个以上的有序表合并成一个新的有序表把含有N 个记录的无序表当成N 个有序的子表, 每个子表的的长度为1, 然后, 利用两两归并, 得到n/2个长度为2或1的有序子表再两两归并直到得到长度为N 的一个有序表</p>
<h1 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h1><p>对于一个有向图, 每两个顶点之间都有路径, 称该图为强连通图</p>
<h1 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h1><p>对于一个无向图, 其极大连通子图叫做该图一个连通分量</p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序是借助 “分配” 和 “收集” 两种操作对单逻辑关键字进行排序的一种内排序方法</p>

      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTk3NS8yMjQ4Ng==">
  <!-- 评论系统 -->
  <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];
         if (typeof LivereTower === 'function') { return; }
  
         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;
  
         e.parentNode.insertBefore(j, e);
     })(document, 'script');
  </script>


  </wenzhang>






        </div>
    </div>
    
<footer id="footer" >
    <span class="konga">
        <a class="jiao"  href="."><</a>
            <input type="text" id="text_input"  placeholder="搜索" >
            
        <a class="jiao"  href=".">></a>
    </span>
    <div id="text_output"></div>
    </div>

</footer>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<bokebangquan>
<!-- 博客版权 -->
<p><strong>
  作者: 我叫史迪奇
  <br>
  本文来自于: 
   <a href="https://sdq3.link/DataStructure-Mustback.html">https://sdq3.link/DataStructure-Mustback.html</a>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</strong></p>

</bokebangqua>


  </div>
  
<script src="/jquery.min.js"></script>

  
<script src="/main.js"></script>

  </body>
</html>
