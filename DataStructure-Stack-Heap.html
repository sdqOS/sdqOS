<!DOCTYPE html>
<html lang="cn">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Text</title>
    <link rel="icon" href="/text.png">
    <!-- 导入css -->
    <link rel="stylesheet" href="/style.css"/>
    <!-- 评论系统 -->
    
    
<script src="/js/waline.js"></script>

    <link href='https://unpkg.com/@waline/client@2.7.1/dist/waline.css' rel='stylesheet' />
  <meta name="generator" content="Hexo 5.4.2"></head>
  <body>

  <div id="page-container">
    <span class="pai">
    <a class="kong" href="/"> 主页 </a>
    <a class="kong" href="/archives"> 分类 </a>
    <a class="kong" href="/about"> 关于 </a>
</span>

    <div id="content-wrap">
        <div class="container">
          <!-- 点击文章 -->
<div>
  <h1>数据结构 栈和堆</h1>
  <wenzhang>
      <div class="contents">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">栈的类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-text">栈的插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">栈的删除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">栈的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InitStack-amp-S-%E6%9E%84%E9%80%A0%E7%A9%BA%E6%A0%88"><span class="toc-text">InitStack (&amp;S) [构造空栈]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%9C-%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%88S"><span class="toc-text">操作结果: 构造一个空栈S</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Push-amp-S-e-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-text">Push (&amp;S, e)  [插入元素]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%9D%A1%E4%BB%B6-%E6%A0%88S%E5%B7%B2%E5%AD%98%E5%9C%A8"><span class="toc-text">初始条件: 栈S已存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%9C-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0e%E4%B8%BA%E6%96%B0%E7%9A%84%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-text">操作结果: 插入元素e为新的栈顶元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pop-amp-S-amp-e-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">Pop (&amp;S, &amp;e) [删除元素]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%9D%A1%E4%BB%B6-%E6%A0%88S%E5%B7%B2%E5%AD%98%E5%9C%A8%E4%B8%94%E9%9D%9E%E7%A9%BA"><span class="toc-text">初始条件: 栈S已存在且非空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%9C-%E5%88%A0%E9%99%A4S%E7%9A%84%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-%E5%B9%B6%E7%94%A8e%E8%BF%94%E5%9B%9E%E5%85%B6%E5%80%BC"><span class="toc-text">操作结果: 删除S的栈顶元素, 并用e返回其值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Print-S-%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0"><span class="toc-text">Print (*S) [打印函数]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%9D%A1%E4%BB%B6-%E6%A0%88S%E5%B7%B2%E5%AD%98%E5%9C%A8%E4%B8%94%E9%9D%9E%E7%A9%BA-1"><span class="toc-text">初始条件: 栈S已存在且非空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%9C-%E5%88%A0%E9%99%A4S%E7%9A%84%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-%E5%B9%B6%E7%94%A8e%E8%BF%94%E5%9B%9E%E5%85%B6%E5%80%BC-1"><span class="toc-text">操作结果: 删除S的栈顶元素, 并用e返回其值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-text">栈的递归调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0-%E4%B8%80%E4%B8%AA%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%88%96%E9%80%9A%E8%BF%87%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E8%B0%83%E7%94%A8%E8%AF%AD%E5%8F%A5%E9%97%B4%E6%8E%A5%E5%9C%B0%E8%B0%83%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">递归函数: 一个直接调用直接或通过一系列的调用语句间接地调用自己的函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">栈类型的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-text">顺序栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%A9%BA%E6%9C%BA%E4%B8%BA-maxsize-%E7%9A%84%E7%A9%BA%E9%A1%BA%E5%BA%8F%E6%A0%88-S"><span class="toc-text">构造一个最大空机为 maxsize 的空顺序栈 S</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-text">链栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%9C%89%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E6%A0%88%E5%B1%9E%E4%BA%8E%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E4%B8%80%E7%A7%8D-%E4%B9%9F%E5%85%B7%E6%9C%89%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">线性表有顺序存储结构和链式存储结构, 栈属于线性表的一种, 也具有顺序存储结构和链式存储结构</span></a></li></ol></li></ol></li></ol>
      </div>
      <p><strong>数据结构学习笔记</strong></p>
<span id="more"></span>

<h1 id="栈的类型定义"><a href="#栈的类型定义" class="headerlink" title="栈的类型定义"></a>栈的类型定义</h1><ul>
<li><p>也称为堆栈, 是一种先进后岀, 删除和插入都在栈顶操作的线性表</p>
<ul>
<li>堆是指重新运行时的动态内存</li>
</ul>
<ul>
<li>栈是指使用堆的方法</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><strong>栈的特性: 先进后出, 后进先出 (最先放入栈的內容最后被拿岀来, 最后放入栈的内容最先被拿出来)</strong></li>
</ul>
<br> 

<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%87%BA%E6%A0%88%E5%85%A5%E6%A0%88.gif"></p>
<br> 


<h2 id="栈的插入"><a href="#栈的插入" class="headerlink" title="栈的插入"></a>栈的插入</h2><br> 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">push()  <span class="hljs-comment">// 在栈顶插入元素</span><br></code></pre></td></tr></table></figure>

<br> 

<h2 id="栈的删除"><a href="#栈的删除" class="headerlink" title="栈的删除"></a>栈的删除</h2><br> 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">pop()  <span class="hljs-comment">// 在栈顶移除一个元素, 并将栈数 -1</span><br></code></pre></td></tr></table></figure>

<br>

<h1 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h1><h2 id="InitStack-amp-S-构造空栈"><a href="#InitStack-amp-S-构造空栈" class="headerlink" title="InitStack (&amp;S) [构造空栈]"></a>InitStack (&amp;S) [构造空栈]</h2><ul>
<li><h3 id="操作结果-构造一个空栈S"><a href="#操作结果-构造一个空栈S" class="headerlink" title="操作结果: 构造一个空栈S"></a>操作结果: 构造一个空栈S</h3></li>
</ul>
<br> 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">Init</span><span class="hljs-params">(SqStack s)</span><br>&#123;<br>    s.base=( <span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(size*<span class="hljs-keyword">sizeof</span>( <span class="hljs-type">int</span> ));<br>    s.top=s.base;<br>    s.stacksize=size;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h2 id="Push-amp-S-e-插入元素"><a href="#Push-amp-S-e-插入元素" class="headerlink" title="Push (&amp;S, e)  [插入元素]"></a>Push (&amp;S, e)  [插入元素]</h2><ul>
<li><h3 id="初始条件-栈S已存在"><a href="#初始条件-栈S已存在" class="headerlink" title="初始条件: 栈S已存在"></a>初始条件: 栈S已存在</h3></li>
</ul>
<ul>
<li><h3 id="操作结果-插入元素e为新的栈顶元素"><a href="#操作结果-插入元素e为新的栈顶元素" class="headerlink" title="操作结果: 插入元素e为新的栈顶元素"></a>操作结果: 插入元素e为新的栈顶元素</h3></li>
</ul>
<br> 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack s, <span class="hljs-type">int</span> e)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(s.top-s.base&gt;s.stacksize)<br>    &#123;<br>        s.base=( <span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(size*<span class="hljs-keyword">sizeof</span>( <span class="hljs-type">int</span> ));<br>        s.top=s.base;<br>        s.stacksize=size;<br>    &#125;   <br>    *s.top++=e;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h2 id="Pop-amp-S-amp-e-删除元素"><a href="#Pop-amp-S-amp-e-删除元素" class="headerlink" title="Pop (&amp;S, &amp;e) [删除元素]"></a>Pop (&amp;S, &amp;e) [删除元素]</h2><ul>
<li><h3 id="初始条件-栈S已存在且非空"><a href="#初始条件-栈S已存在且非空" class="headerlink" title="初始条件: 栈S已存在且非空"></a>初始条件: 栈S已存在且非空</h3></li>
</ul>
<ul>
<li><h3 id="操作结果-删除S的栈顶元素-并用e返回其值"><a href="#操作结果-删除S的栈顶元素-并用e返回其值" class="headerlink" title="操作结果: 删除S的栈顶元素, 并用e返回其值"></a>操作结果: 删除S的栈顶元素, 并用e返回其值</h3></li>
</ul>
<br> 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack s, <span class="hljs-type">int</span> e)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(s.top-s.base&gt;s.stacksize)<br>    &#123;<br>        s.base=( <span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(size*<span class="hljs-keyword">sizeof</span>( <span class="hljs-type">int</span> ));<br>        s.top=s.base;<br>        s.stacksize=size;<br>    &#125;   <br>    *s.top++=e;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h2 id="Print-S-打印函数"><a href="#Print-S-打印函数" class="headerlink" title="Print (*S) [打印函数]"></a>Print (*S) [打印函数]</h2><ul>
<li><h3 id="初始条件-栈S已存在且非空-1"><a href="#初始条件-栈S已存在且非空-1" class="headerlink" title="初始条件: 栈S已存在且非空"></a>初始条件: 栈S已存在且非空</h3></li>
</ul>
<ul>
<li><h3 id="操作结果-删除S的栈顶元素-并用e返回其值-1"><a href="#操作结果-删除S的栈顶元素-并用e返回其值-1" class="headerlink" title="操作结果: 删除S的栈顶元素, 并用e返回其值"></a>操作结果: 删除S的栈顶元素, 并用e返回其值</h3></li>
</ul>
<br> 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">(SqStack *s)</span><br>&#123;<br>    <span class="hljs-type">int</span> * temp;<br>    temp = s -&gt; top;<br>    <span class="hljs-keyword">while</span> ( temp != s -&gt; base)<br>    &#123;<br>        temp--;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*temp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h1 id="栈的递归调用"><a href="#栈的递归调用" class="headerlink" title="栈的递归调用"></a>栈的递归调用</h1><ul>
<li><h3 id="递归函数-一个直接调用直接或通过一系列的调用语句间接地调用自己的函数"><a href="#递归函数-一个直接调用直接或通过一系列的调用语句间接地调用自己的函数" class="headerlink" title="递归函数: 一个直接调用直接或通过一系列的调用语句间接地调用自己的函数"></a>递归函数: 一个直接调用直接或通过一系列的调用语句间接地调用自己的函数</h3></li>
</ul>
<br> 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span> <span class="hljs-params">( <span class="hljs-type">int</span> m )</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( m==<span class="hljs-number">1</span> )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        printd(<span class="hljs-string">&quot;m=%d\n&quot;</span>,m);<br>        <span class="hljs-keyword">return</span> f ( m - <span class="hljs-number">1</span> );<br>    &#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">f</span> <span class="hljs-params">( <span class="hljs-type">int</span> m)</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一个大于1的数: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f(n));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<br>


<h1 id="栈类型的实现"><a href="#栈类型的实现" class="headerlink" title="栈类型的实现"></a>栈类型的实现</h1><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><ul>
<li><h3 id="构造一个最大空机为-maxsize-的空顺序栈-S"><a href="#构造一个最大空机为-maxsize-的空顺序栈-S" class="headerlink" title="构造一个最大空机为 maxsize 的空顺序栈 S"></a>构造一个最大空机为 maxsize 的空顺序栈 S</h3></li>
</ul>
<br> 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta"># <span class="hljs-keyword">define</span> STACK_INIT_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    SElemType *base;<br>    SElemType *top;<br>    <span class="hljs-type">int</span> stacksize;<br>&#125; SqStack;<br><br>Status <span class="hljs-title function_">InitStack</span> <span class="hljs-params">( SqStack &amp;S, <span class="hljs-type">int</span> maxsize )</span><br>&#123;<br>        S.base = new ElemType[maxsize];<br>    <span class="hljs-comment">// 储存分配失败</span><br>    <span class="hljs-keyword">if</span> ( !S.base ) <span class="hljs-built_in">exit</span> ( OVERFLOW );<br>    S.top = S.base;<br>    S.stacksize = Maxsize;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 栈的插入</span><br>Status <span class="hljs-title function_">Push</span> <span class="hljs-params">( SqStack &amp;S, SElemType e )</span><br>&#123;<br>    <span class="hljs-comment">// 若栈不满, 则将 e 插入栈顶</span><br>    <span class="hljs-comment">// 栈满</span><br>    <span class="hljs-keyword">if</span> ( S.top - S.base &gt;= S.stacksize )<br>        <span class="hljs-keyword">return</span> OVERFLOW;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 栈的删除</span><br>Status <span class="hljs-title function_">Pop</span> <span class="hljs-params">( SqStack &amp;S, SElemType &amp;e )</span><br>&#123;<br>    <span class="hljs-comment">// 若栈不空, 则删除 S 的栈顶元素</span><br>    <span class="hljs-comment">// 用 额返回其值, 并返回OK 否则返回 ERROR</span><br>    <span class="hljs-keyword">if</span> ( S.top == S.base ) <span class="hljs-keyword">return</span> ERROR;<br>    e = *--S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><ul>
<li><h3 id="线性表有顺序存储结构和链式存储结构-栈属于线性表的一种-也具有顺序存储结构和链式存储结构"><a href="#线性表有顺序存储结构和链式存储结构-栈属于线性表的一种-也具有顺序存储结构和链式存储结构" class="headerlink" title="线性表有顺序存储结构和链式存储结构, 栈属于线性表的一种, 也具有顺序存储结构和链式存储结构"></a>线性表有顺序存储结构和链式存储结构, 栈属于线性表的一种, 也具有顺序存储结构和链式存储结构</h3></li>
</ul>
<br>

<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E6%A0%88.jpg"></p>
<br>
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTk3NS8yMjQ4Ng==">
  <!-- 评论系统 -->
  <!-- 评论系统 -->
<body>
  <!-- ... -->
  <div id="vcomments" class="comment">

  </div>
  <script>
  
    Waline.init({
      el: '#vcomments',
      serverURL: 'https://comments.sdq3.link/'
    });
  </script>
    </wenzhang>






        </div>
    </div>
    
<footer id="footer" >
    <span class="konga">
        <a class="jiao"  href="."><</a>
            <input type="text" id="text_input"  placeholder="搜索" >
            
        <a class="jiao"  href=".">></a>
    </span>
    <div id="text_output"></div>
    </div>

</footer>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<bokebangquan>
<!-- 博客版权 -->
<p><strong>
  作者: 我叫史迪奇
  <br>
  本文来自于: 
   <a href="https://sdq3.link/DataStructure-Stack-Heap.html">https://sdq3.link/DataStructure-Stack-Heap.html</a>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</strong></p>

</bokebangqua>
  </div>
  
<script src="/jquery.min.js"></script>

  
<script src="/main.js"></script>

  </body>
</html>
